@top Input { Items }

// macros

sepBy<content, sep> {
	"" | content (sep content?)*
}

// Similar to `sepEndBy1`
sepBy1<content, sep> {
  content (sep content?)*
}

commaSep<content> {
  sepBy<content, ",">
}

commaSep1<content> {
	sepBy1<content, ",">
}

kw<term> { @specialize[@name={term}]<Identifier, term> }

// grammar

Items {
  (Item)*
}

Item {
  HeaderBlock { Header Block }
  | LayoutStages { kw<"layout">  "="  StageList }
}

StageList {
	"[" commaSep1<Stage> "]"
}

Stage {
	Identifier
}

Header {
  Selector
  | Namespace
  | Collector
}

// Selector rules

Selector {
  kw<"forall"> kw<"repeatable">? DeclList (
		Where? With?
		| With? Where?
	)
}

Where { kw<"where"> RelationList }

With { kw<"with"> DeclList }

Foreach { kw<"foreach"> DeclList }

Namespace { Identifier }

DeclList { sepBy1<DeclPattern, ";"> }

DeclPattern { SelType commaSep1<Variable> }

Decl { SelType Variable }

SelType { Identifier }
Variable {
	StyVar { Identifier }
	| SubVar { "`" Identifier "`" }
}

RelationList { sepBy1<Relation, ";"> }

Relation { Bind | Pred | Field }

Bind { Variable ":=" RelExpr }

Pred {Identifier "(" Args ")" As?}

As { kw<"as"> Identifier }

RelExpr { Func | Arg }

Func { Identifier "(" commaSep<RelExpr> ")" }

Arg { Variable | Literal }

Literal { Number | String }

Args { sepBy1<Arg, ","> }

Field { Variable kw<"has"> FieldDesc? Identifier}

FieldDesc { kw<"math"> | kw<"text"> }

// collector rules

Collector {
	kw<"collect"> kw<"repeatable">? Decl Into (
		Where? With? Foreach? |
		Where? Foreach? With? |
		With? Where? Foreach? |
		With? Foreach? Where? |
		Foreach? Where? With? |
		Foreach? With? Where?
	)
}

Into { kw<"into"> Identifier }

// block rules

Block { "{" sepBy<Statement, semi> "}" }
Statement { Delete | Override | Assign | AnonExpr }
Delete { kw<"delete"> Path }
Override { kw<"override"> Path "=" AssignExpr }
Assign { Type? Path "=" AssignExpr }

Path { Variable ("." Identifier)* AccessOps? }
AccessOps { AccessOp (AccessOp)* }
AccessOp { "[" Expr "]" }

// expression rules
AnonExpr { Layering | Objective | Constraint | ShapeDecl }
AssignExpr { Expr | Layering | Objective | Constraint | ShapeDecl }

Expr { 
	BooleanLiteral |
	ColorLiteral |
	String |
	AnnotatedFloat |
	ComputationFunction |
	StyVarExpr |
	Path |
	List |
	Tuple |
	Vector |
	BinaryExpression { Expr BinOp Expr } 
}

AnnotatedFloat { "?" | Number } 
ComputationFunction { Identifier "(" commaSep<Expr> ")" }
StyVarExpr {
	kw<"listof"> Identifier kw<"from"> Identifier |
	(kw<"numberof"> | kw<"nameof">) Identifier
}
List { "[" commaSep<Expr> "]" }
Tuple { "{" Expr "," Expr "}" }
Vector { "(" commaSep1<Expr> ")" }
Layering { 
	kw<"layer">? Path (kw<"above"> | kw<"below">) commaSep1<Path> 
}
Objective {
	kw<"encourage"> 
}
Constraint {
	kw<"ensure"> Identifier "(" commaSep<Expr> ")"	
}
ObjConstrBody {
	// function call
	Identifier "(" commaSep<Expr> ")" |
	// comparison expr
	Expr CompareOp Expr 
}
ShapeDecl {
	Identifier sepBy<PropertyDecl, semi>
}
PropertyDecl { Identifier ":" Expr }
Type {
	kw<"scalar"> |
	kw<"int"> |
	kw<"bool"> |
	kw<"string"> |
	kw<"path"> |
	kw<"color"> |
	kw<"file"> |
	kw<"style"> |
	kw<"shape"> | 
	kw<"list"> |
	kw<"vec2"> |
	kw<"vec3"> |
	kw<"vec4"> |
	kw<"mat2x2"> |
	kw<"mat3x3"> |
	kw<"mat4x4"> |
	kw<"function"> |
	kw<"objective"> |
	kw<"constraint"> 
}

// skips and tokens 

@external tokens insertSemicolon from "./substanceTokens.js" { insertSemi }
@context trackNewline from "./substanceTokens.js"
semi { ";" | insertSemi }

@skip { spaces | newline | LineComment 
	| BlockComment { "/*" (blockCommentContent | blockCommentNewline)* blockCommentEnd }
}

// handle block comment content
@local tokens {
  blockCommentEnd { "*/" }
  blockCommentNewline { "\n" }
  @else blockCommentContent
}


@tokens {
	hex { @digit | $[a-fA-F] }
	stringContentDouble { ![\\\n"]+ }
	identifierChar { @asciiLetter | $[_$\u{a1}-\u{10ffff}] }
  word { identifierChar (identifierChar | @digit)* }
  Identifier { word }
	LineComment { "--" ![\n]* }
  spaces { $[ \t]+ }
  newline { "\n" }
  eof { @eof }
	Number {
		(@digit ("_" | @digit)* ("." ("_" | @digit)*)? | "." @digit ("_" | @digit)*)
			(("e" | "E") ("+" | "-")? ("_" | @digit)+)?
	}

	String {
		'"' (stringContentDouble | Escape)* ('"' | "\n") 
		// "'" (stringContentSingle | Escape)* ("'" | "\n")
	}
	Escape {
		"\\" ("x" hex hex | "u" ("{" hex+ "}" | hex hex hex hex) | ![xu])
	}
  ColorLiteral { "#" hex hex hex (hex (hex hex (hex hex)?)?)?  }
	"."
	"("[@name=LParen]
	")"[@name=RParen]
	":="[@name=Bind]
	BooleanLiteral { "true" | "false" }
	BinOp { $[+\-*/] | ".*" | "./" | "then" }
	CompareOp { "<" | "==" | ">" }


	@precedence { Number "." }
}




